# [填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

### 题目描述

给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```c++
struct Node {
    int val;
    Node *left;
    Node *right;
    Node *next;
};
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

##### 进阶

你只能使用常量级额外空间。

使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

##### 示例

> 输入：root = [1,2,3,4,5,6,7]
>
> 输出：[1,#,2,3,#,4,5,6,7,#]
>
> 解释：给定二叉树如图所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。

![img](Photo/1.png)

##### 提示

- 树中节点的数量少于 4096
- -1000 <= node.val <= 1000

### 解题思路

##### 方法一：树的前序遍历

二叉树的问题难点在于，如何把题目的要求细化成每个节点需要做的事情，但是如果只依赖一个节点的话，肯定是没有办法连接**跨父节点**的两个相邻节点。

那么，增加函数参数，**将每一层二叉树节点连接起来**可以细化成**将每两个相邻节点都连接起来**。

时间复杂度：O(N)

空间复杂度：O(N)

##### 方法二：树的层次遍历

借助队列，对树的每一层的节点进行操作。

时间复杂度：O(N)

空间复杂度：O(N)

##### 方法三：借助 next 指针

当第 N 层各节点之间建立 next 指针后，再建立 N+1 层节点的 next 指针。可以通过 next 指针访问同一层的所有节点，因此可以使用第 N 层的 next 指针，为第 N+1 层节点建立 next 指针。

遍历下一层时，需要临时保存上一层的节点指针，便于遍历上层所有节点。

时间复杂度：O(N)

空间复杂度：O(1)