# [任务调度器](https://leetcode-cn.com/problems/task-scheduler/)

### 题目描述

给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。

然而，两个相同种类的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的最短时间。

##### 示例

> 输入：tasks = ["A","A","A","B","B","B"], n = 2
>
> 输出：8
>
> 解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B。在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。

> 输入：tasks = ["A","A","A","B","B","B"], n = 0
>
> 输出：6
>
> 解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0

> 输入：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
>
> 输出：16
>
> 解释：一种可能的解决方案是：A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A

##### 提示

- 1 <= task.length <= 104
- tasks[i] 是大写英文字母
- n 的取值范围为 [0, 100]

### 解题思路

##### 方法一：

算是规律吧，查找出需要执行次数最多的任务（max），以及次数最多且相同的任务的数量（count）。次数最多的任务需要全部执行，所以最多需要 max\*(n+1) 次，但最后一轮可能只需要执行 1 个任务，即最少需要 (max-1)*(n+1)+1 次，当 count 大于1时，最后一轮需要执行 count 个任务。即 (max-1)\*(n+1)+count 次，若该值小于任务的数量，则表明所有任务都能排上，中间不需要待命，所以需要 tasks.size() 次。

举例：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2

| A    | B    | C    |
| ---- | ---- | ---- |
| A    | D    | E    |
| A    | F    | G    |
| A    | 待命 | 待命 |
| A    | 待命 | 待命 |
| A    | 无   | 无   |

tasks = ["A","A","A","B","B","B"], n = 2

| A    | B    | 待命 |
| ---- | ---- | ---- |
| A    | B    | 待命 |
| A    | B    | 无   |

时间复杂度：O(n)，n为task的数量

空间复杂度：O(task的种类)